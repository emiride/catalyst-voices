<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `_UNUSED_CODE` constant in crate `cat_gateway`."><title>_UNUSED_CODE in cat_gateway::cardano - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-405f8b29f52305f8.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="cat_gateway" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0-nightly (506f22b46 2024-09-19)" data-channel="nightly" data-search-js="search-0cfde64e8ad3a7fe.js" data-settings-js="settings-7e3bb6c46e92e77c.js" ><script src="../../static.files/storage-29b1d5a9048d38fe.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-59a36e46ca746814.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-40f72c9259523cb3.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../cat_gateway/index.html">cat_<wbr>gateway</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="index.html">In cat_<wbr>gateway::<wbr>cardano</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Constant <a href="../index.html">cat_gateway</a>::<wbr><a href="index.html">cardano</a>::<wbr><a class="constant" href="#">_UNUSED_CODE</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/cat_gateway/cardano/mod.rs.html#383-725">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>const _UNUSED_CODE: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> = r#&quot;

/// Spawn follower threads and return associated handlers
async fn spawn_followers(
    configs: Vec&lt;FollowerConfig&gt;, _data_refresh_tick: u64, machine_id: String,
) -&gt; anyhow::Result&lt;Vec&lt;ManageTasks&gt;&gt; {
    let mut follower_tasks = Vec::new();

    for config in &amp;configs {
        let follower_handler = spawn_follower(
            config.network,
            &amp;config.relay,
            machine_id.clone(),
            &amp;config.mithril_snapshot.path,
        )
        .await?;

        follower_tasks.push(follower_handler);
    }

    Ok(follower_tasks)
}

/// Initiate single follower and returns associated task handler
/// which facilitates future control over spawned threads.
async fn spawn_follower(
    network: Network, relay: &amp;str, machine_id: MachineId, snapshot: &amp;str,
) -&gt; anyhow::Result&lt;ManageTasks&gt; {
    // Establish point at which the last follower stopped updating in order to pick up
    // where it left off. If there was no previous follower, start indexing from
    // genesis point.
    let start_from = match EventDB::last_updated_state(network).await {
        Ok((slot_no, block_hash, _)) =&gt; Point::new(slot_no.try_into()?, block_hash),
        Err(err) if err.is::&lt;NotFoundError&gt;() =&gt; Point::Origin,
        Err(err) =&gt; return Err(err),
    };

    info!(&quot;Starting {network:?} follower from {start_from:?}&quot;,);

    let mut follower = instantiate_follower(start_from, snapshot, network, relay).await?;

    let genesis_values = network_genesis_values(&amp;network)
        .ok_or(anyhow::anyhow!(&quot;Obtaining genesis values failed&quot;))?;

    let task = tokio::spawn(async move {
        process_blocks(&amp;mut follower, network, machine_id, &amp;genesis_values).await;
    });

    Ok(task)
}

/// Process next block from the follower
async fn process_blocks(
    follower: &amp;mut Follower, network: Network, machine_id: MachineId,
    genesis_values: &amp;GenesisValues,
) {
    info!(&quot;Follower started processing blocks&quot;);

    let (blocks_tx, mut blocks_rx) = mpsc::channel(1);

    tokio::spawn({
        let genesis_values = genesis_values.clone();

        async move {
            let mut blocks_buffer = Vec::new();

            let mut ticker = tokio::time::interval(Duration::from_secs(60));
            ticker.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Delay);

            loop {
                tokio::select! {
                    res = blocks_rx.recv() =&gt; {
                        match res {
                            Some(block_data) =&gt; {
                                blocks_buffer.push(block_data);

                                if blocks_buffer.len() &gt;= MAX_BLOCKS_BATCH_LEN {
                                    index_block_buffer(&amp;genesis_values, network, &amp;machine_id, std::mem::take(&amp;mut blocks_buffer)).await;

                                    // Reset batch ticker since we just indexed the blocks buffer
                                    ticker.reset();
                                }
                            }

                            None =&gt; {
                                break;
                            }
                        }
                    }

                    _ = ticker.tick() =&gt; {
                        // This executes when we have not indexed blocks for more than the configured
                        // tick interval. This means that if any errors occur in that time we lose the buffered block data (e.g.
                        // cat-gateway is shutdown ungracefully). This is not a problem since cat-gateway
                        // checkpoints the latest database writes so it simply restarts from the last
                        // written block.
                        //
                        // This is most likely to happen when following from the tip or receiving blocks
                        // from the network (since updates will come at larger intervals).
                        if blocks_buffer.is_empty() {
                            continue;
                        }

                        let current_buffer = std::mem::take(&amp;mut blocks_buffer);
                        index_block_buffer(&amp;genesis_values, network, &amp;machine_id, current_buffer).await;

                        // Reset the ticker so it counts the interval as starting after we wrote everything
                        // to the database.
                        ticker.reset();
                    }
                }
            }
        }
    });

    loop {
        match follower.next().await {
            Ok(chain_update) =&gt; {
                match chain_update {
                    ChainUpdate::Block(data) =&gt; {
                        if blocks_tx.send(data).await.is_err() {
                            error!(&quot;Block indexing task not running&quot;);
                            break;
                        };
                    },
                    ChainUpdate::Rollback(data) =&gt; {
                        let block = match data.decode() {
                            Ok(block) =&gt; block,
                            Err(err) =&gt; {
                                error!(&quot;Unable to decode {network:?} block {err} - skip..&quot;);
                                continue;
                            },
                        };

                        info!(
                            &quot;Rollback block NUMBER={} SLOT={} HASH={}&quot;,
                            block.number(),
                            block.slot(),
                            hex::encode(block.hash()),
                        );
                    },
                }
            },
            Err(err) =&gt; {
                error!(
                        &quot;Unable to receive next update from the {network:?} follower err: {err} - skip..&quot;,
                    );
                continue;
            },
        }
    }
}

/// Consumes a block buffer and indexes its data.
async fn index_block_buffer(
    genesis_values: &amp;GenesisValues, network: Network, machine_id: &amp;MachineId,
    buffer: Vec&lt;cardano_chain_follower::MultiEraBlockData&gt;,
) {
    info!(&quot;Starting data batch indexing&quot;);

    let mut blocks = Vec::new();

    for block_data in &amp;buffer {
        match block_data.decode() {
            Ok(block) =&gt; blocks.push(block),
            Err(e) =&gt; {
                error!(error = ?e, &quot;Failed to decode block&quot;);
            },
        }
    }

    match index_many_blocks(genesis_values, network, machine_id, &amp;blocks).await {
        Ok(()) =&gt; {
            info!(&quot;Finished indexing data batch&quot;);
        },
        Err(e) =&gt; {
            error!(error = ?e, &quot;Failed indexing data batch&quot;);
        },
    }
}

/// Index a slice of blocks.
async fn index_many_blocks(
    genesis_values: &amp;GenesisValues, network: Network, machine_id: &amp;MachineId,
    blocks: &amp;[MultiEraBlock&lt;&#39;_&gt;],
) -&gt; anyhow::Result&lt;()&gt; {
    let Some(last_block) = blocks.last() else {
        return Ok(());
    };

    let network_str = network.to_string();

    index_blocks(genesis_values, &amp;network_str, blocks).await?;
    index_transactions(blocks, &amp;network_str).await?;
    index_voter_registrations(blocks, network).await?;

    match EventDB::refresh_last_updated(
        chrono::offset::Utc::now(),
        last_block.slot().try_into()?,
        last_block.hash().to_vec(),
        network,
        machine_id,
    )
    .await
    {
        Ok(()) =&gt; {},
        Err(err) =&gt; {
            error!(&quot;Unable to mark {network:?} last update point {err} - skip..&quot;,);
        },
    };

    Ok(())
}

/// Index the data from the given blocks.
async fn index_blocks(
    genesis_values: &amp;GenesisValues, network_str: &amp;str, blocks: &amp;[MultiEraBlock&lt;&#39;_&gt;],
) -&gt; anyhow::Result&lt;usize&gt; {
    let values: Vec&lt;_&gt; = blocks
        .iter()
        .filter_map(|block| {
            IndexedFollowerDataParams::from_block_data(genesis_values, network_str, block)
        })
        .collect();

    EventDB::index_many_follower_data(&amp;values)
        .await
        .context(&quot;Indexing block data&quot;)?;

    Ok(values.len())
}

/// Index transactions (and its inputs and outputs) from a slice of blocks.
async fn index_transactions(blocks: &amp;[MultiEraBlock&lt;&#39;_&gt;], network_str: &amp;str) -&gt; anyhow::Result&lt;()&gt; {
    let blocks_txs: Vec&lt;_&gt; = blocks
        .iter()
        .flat_map(|b| b.txs().into_iter().map(|tx| (b.slot(), tx)))
        .collect();

    index_transactions_data(network_str, &amp;blocks_txs).await?;
    index_transaction_outputs_data(&amp;blocks_txs).await?;
    index_transaction_inputs_data(&amp;blocks_txs).await?;

    Ok(())
}

/// Index transactions data.
async fn index_transactions_data(
    network_str: &amp;str, blocks_txs: &amp;[(u64, MultiEraTx&lt;&#39;_&gt;)],
) -&gt; anyhow::Result&lt;usize&gt; {
    let values: Vec&lt;_&gt; = blocks_txs
        .iter()
        .map(|(slot, tx)| {
            Ok(IndexedTxnParams {
                id: tx.hash().to_vec(),
                slot_no: (*slot).try_into()?,
                network: network_str,
            })
        })
        .collect::&lt;anyhow::Result&lt;Vec&lt;_&gt;&gt;&gt;()?;

    EventDB::index_many_txn_data(&amp;values)
        .await
        .context(&quot;Indexing transaction data&quot;)?;

    Ok(values.len())
}

/// Index transaction outputs data.
async fn index_transaction_outputs_data(
    blocks_txs: &amp;[(u64, MultiEraTx&lt;&#39;_&gt;)],
) -&gt; anyhow::Result&lt;usize&gt; {
    let values: Vec&lt;_&gt; = blocks_txs
        .iter()
        .flat_map(|(_, tx)| IndexedTxnOutputParams::from_txn_data(tx))
        .collect();

    EventDB::index_many_txn_output_data(&amp;values)
        .await
        .context(&quot;Indexing transaction outputs&quot;)?;

    Ok(values.len())
}

/// Index transaction inputs data.
async fn index_transaction_inputs_data(
    blocks_txs: &amp;[(u64, MultiEraTx&lt;&#39;_&gt;)],
) -&gt; anyhow::Result&lt;usize&gt; {
    let values: Vec&lt;_&gt; = blocks_txs
        .iter()
        .flat_map(|(_, tx)| IndexedTxnInputParams::from_txn_data(tx))
        .collect();

    EventDB::index_many_txn_input_data(&amp;values)
        .await
        .context(&quot;Indexing transaction inputs&quot;)?;

    Ok(values.len())
}

/// Index voter registrations from a slice of blocks.
async fn index_voter_registrations(
    blocks: &amp;[MultiEraBlock&lt;&#39;_&gt;], network: Network,
) -&gt; anyhow::Result&lt;usize&gt; {
    let values: Vec&lt;_&gt; = blocks
        .iter()
        .filter_map(|block| IndexedVoterRegistrationParams::from_block_data(block, network))
        .flatten()
        .collect();

    EventDB::index_many_voter_registration_data(&amp;values)
        .await
        .context(&quot;Indexing voter registration&quot;)?;

    Ok(values.len())
}

/// Instantiate the follower.
/// If there is metadata present which allows us to bootstrap from a point in time
/// We start from there, if not; we start from genesis.
async fn instantiate_follower(
    start_from: Point, snapshot: &amp;str, network: Network, relay: &amp;str,
) -&gt; anyhow::Result&lt;Follower&gt; {
    let mut follower_cfg = FollowerConfigBuilder::default()
        .follow_from(start_from)
        .mithril_snapshot_path(PathBuf::from(snapshot))
        .build();

    let follower = match Follower::connect(relay, network, follower_cfg.clone()).await {
        Ok(follower) =&gt; follower,
        Err(err) =&gt; {
            error!(&quot;Unable to bootstrap via mithril snapshot {err}. Trying network..&quot;,);

            // We know bootstrapping from the snapshot fails, remove path and try from network
            follower_cfg.mithril_snapshot_path = None;
            Follower::connect(relay, network, follower_cfg).await?
        },
    };

    Ok(follower)
}

&quot;#;</code></pre></section></div></main></body></html>