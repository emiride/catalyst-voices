searchState.loadedDescShard("cbork_cddl_parser", 0, "A parser for CDDL, utilized for parsing in accordance with …\nAbstract Syntax Tree (AST) representing parsed CDDL syntax.\nRepresents the AST for CDDL Modules rules.\nAn error related to CDDL modules extension.\nRepresents an error that may occur during CDDL parsing.\nRepresents different types of errors related to different …\nRFC8610, RFC9165, and CDDL modules.\nRepresents different parser extensions for handling CDDL …\nA trait with a single method that parses strings.\nRepresents the AST for RFC 8610 CDDL rules.\nAn error related to RFC 8610 extension.\nRFC8610 ONLY limited parser.\nRepresents the AST for RFC 9165 CDDL rules.\nAn error related to RFC 9165 extension.\nRFC8610 and RFC9165 limited parser.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParses a <code>&amp;str</code> starting from <code>rule</code>.\nParses and checks semantically a CDDL input string.\nAll Visible Ascii characters.\nThe set of characters valid for a byte string.\nAscii subset valid for byte text strings.\nEnd-of-input\nA pair of hex digits. (Must always have even numbers of …\nA name can end with an alphabetic character (including “@…\nA name can start with an alphabetic character (including …\nAll Visible characters.\nA trait with a single method that parses strings.\nCDDL Grammar adapted from RFC8610 Appendix B …\nThe set of characters valid for a text string.\nAscii subset valid for text strings.\nEscaping code to allow invalid characters to be used in …\nValid non ascii unicode Characters\nWhitespace is allowed and is ignored. This token will keep …\nLiteral Bytes.\nExponent for a number\nFractional part of a number\nReturns the argument unchanged.\nReturns the argument unchanged.\nSpecial form of a name that represents a Group Socket.\nHex floats of the form -0x123.abc0p+12\nidentifier, called the <code>name</code> in the CDDL spec.\nAll integers, singed and unsigned\nInts or Int floats\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGeneral form of a name.\nLiteral Numbers - A float if it has fraction or exponent; …\nOptional Comma - Note eligible for producing pairs as this …\nParses a <code>&amp;str</code> starting from <code>rule</code>.\nLiteral Text\nSpecial form of a name that represents a Type Socket.\nUnsigned Integers\nAll Literal Values\nAll Visible Ascii characters.\nThe set of characters valid for a byte string.\nAscii subset valid for byte text strings.\nTest Expression for the <code>COMMENT</code> Rule.\nEnd-of-input\nA pair of hex digits. (Must always have even numbers of …\nA name can end with an alphabetic character (including “@…\nA name can start with an alphabetic character (including …\nAll Visible characters.\nA trait with a single method that parses strings.\nCDDL Grammar adapted from RFC8610 Appendix B …\nThe set of characters valid for a text string.\nAscii subset valid for text strings.\nEscaping code to allow invalid characters to be used in …\nTest Expression for the <code>S</code> Rule.\nValid non ascii unicode Characters\nWhitespace is allowed and is ignored. This token will keep …\nTest expression for the URL_BASE64 Rule.\nTest Expression for the <code>assigng</code> Rule.\nTest Expression for the <code>assignt</code> Rule.\nTest Expression for the <code>bareword</code> Rule.\nLiteral Bytes.\nTest expression to the <code>bytes</code> Rule.\nTest Expression for the <code>ctlop</code> Rule.\nExponent for a number\nFractional part of a number\nReturns the argument unchanged.\nReturns the argument unchanged.\nTest Expression for the <code>genericarg</code> Rule.\nTest Expression for the <code>genericparm</code> Rule.\nTest Expression for the <code>group</code> Rule.\nSpecial form of a name that represents a Group Socket.\nTest Expression for the <code>groupname</code> Rule.\nTest Expression for the <code>grpchoice</code> Rule.\nTest Expression for the <code>grpent</code> Rule.\nHex floats of the form -0x123.abc0p+12\nTest expression to the <code>hexfloat</code> Rule.\nidentifier, called the <code>name</code> in the CDDL spec.\nTest expression to the <code>id</code> Rule.\nAll integers, singed and unsigned\nTest expression to the <code>int</code> Rule.\nInts or Int floats\nTest expression to the <code>intfloat</code> Rule.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTest Expression for the <code>memberkey</code> Rule.\nGeneral form of a name.\nLiteral Numbers - A float if it has fraction or exponent; …\nTest expression to the <code>number</code> Rule.\nTest Expression for the <code>occur</code> Rule.\nOptional Comma - Note eligible for producing pairs as this …\nTest Expression for the <code>optcom</code> Rule.\nParses a <code>&amp;str</code> starting from <code>rule</code>.\nTest Expression for the <code>rangeop</code> Rule.\nTest Expression for the <code>rule</code> Rule.\nLiteral Text\nTest expression to the <code>text</code> Rule.\nTest Expression for the <code>type1</code> Rule.\nTest Expression for the <code>type2</code> Rule.\nTest Expression for the <code>type</code> Rule.\nSpecial form of a name that represents a Type Socket.\nTest Expression for the <code>typename</code> Rule.\nUnsigned Integers\nTest expression to the <code>uint</code> Rule.\nAll Literal Values\nTest expression to the <code>value</code> Rule.\nAll Visible Ascii characters.\nThe set of characters valid for a byte string.\nAscii subset valid for byte text strings.\nEnd-of-input\nA pair of hex digits. (Must always have even numbers of …\nA name can end with an alphabetic character (including “@…\nA name can start with an alphabetic character (including …\nAll Visible characters.\nA trait with a single method that parses strings.\nCDDL Grammar adapted from RFC8610 Appendix B …\nThe set of characters valid for a text string.\nAscii subset valid for text strings.\nEscaping code to allow invalid characters to be used in …\nValid non ascii unicode Characters\nWhitespace is allowed and is ignored. This token will keep …\nLiteral Bytes.\nExponent for a number\nFractional part of a number\nReturns the argument unchanged.\nReturns the argument unchanged.\nSpecial form of a name that represents a Group Socket.\nHex floats of the form -0x123.abc0p+12\nidentifier, called the <code>name</code> in the CDDL spec.\nAll integers, singed and unsigned\nInts or Int floats\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGeneral form of a name.\nLiteral Numbers - A float if it has fraction or exponent; …\nOptional Comma - Note eligible for producing pairs as this …\nParses a <code>&amp;str</code> starting from <code>rule</code>.\nLiteral Text\nSpecial form of a name that represents a Type Socket.\nUnsigned Integers\nAll Literal Values\nAll Visible Ascii characters.\nThe set of characters valid for a byte string.\nAscii subset valid for byte text strings.\nEnd-of-input\nA pair of hex digits. (Must always have even numbers of …\nA name can end with an alphabetic character (including “@…\nA name can start with an alphabetic character (including …\nAll Visible characters.\nA trait with a single method that parses strings.\nCDDL Grammar adapted from RFC8610 Appendix B …\nThe set of characters valid for a text string.\nAscii subset valid for text strings.\nEscaping code to allow invalid characters to be used in …\nValid non ascii unicode Characters\nWhitespace is allowed and is ignored. This token will keep …\nLiteral Bytes.\nExponent for a number\nFractional part of a number\nReturns the argument unchanged.\nReturns the argument unchanged.\nSpecial form of a name that represents a Group Socket.\nHex floats of the form -0x123.abc0p+12\nidentifier, called the <code>name</code> in the CDDL spec.\nAll integers, singed and unsigned\nInts or Int floats\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGeneral form of a name.\nLiteral Numbers - A float if it has fraction or exponent; …\nOptional Comma - Note eligible for producing pairs as this …\nParses a <code>&amp;str</code> starting from <code>rule</code>.\nLiteral Text\nSpecial form of a name that represents a Type Socket.\nUnsigned Integers\nAll Literal Values")