searchState.loadedDescShard("cardano_chain_follower", 0, "Cardano chain follower.\nNew block inserted on chain.\nThe Chain Follower\nA Follower Connection to the Cardano Network.\nActual Chain Update itself.\nContains the error value\nA new part of the chain has become immutable …\nEnum of chain updates received by the follower.\nCardano mainnet network.\nMulti-era block.\nEnum of possible Cardano networks.\nThe origin of the blockchain. It is used when the interest …\nContains the success value\nA specific point in the blockchain. It can be used to …\nCardano pre-production network.\nCardano preview network.\nCrate result type.\nChain rollback to the given block.\nStatistics for a single follower network.\nThe tip of the blockchain at the current moment. It is …\nThe Blockchain network we are following.\nChain Network\nSync from the chain to an in-memory buffer.\nCardano chain sync configuration.\nStorage of each Live Chain per Blockchain.\nFlag to control if chain sync for a blockchain is ready. …\nAn update of a blockchain\nBlock buffer size option.\nWhere we are currently in the following process.\nWhat is the new data?\nWhere we end following.\nLibrary Crates Defined Errors\nCardano chain follow module.\nWhat fork were we last on\nWhat fork is the block on? This is NOT part of the inner …\nIf we don’t have immutable data, how far back from TIP …\nThe Immutable decoded data about the block itself.\nWhat kind of update is this?\nStatistics related to the live connection to the …\nMetadata decoding and validating.\nStatistics related to the mithril certified blockchain …\nConfiguration of Mithril Snapshots.\nMithril Snapshot Follower\nFunctions which query or interact with the Immutable …\nInternal Mithril snapshot functions.\nConfiguration for the Mithril Snapshot used by the …\nData about the current Mithril Snapshot\nInternal Mithril snapshot iterator functions.\nInternal Mithril snapshot downloader task.\nMithril TIP Reached\nTurbo Downloads for Mithril Snapshots.\nMulti Era CBOR Encoded Block Data\nEnum of possible Cardano networks.\nA Cardano Point on the Blockchain.\nBlock we processed most recently.\nRelay Node Address\nMithril Snapshot\nSimple ID for a mithril snapshot path known by its largest …\nCardano Chain Follower Statistics\nLive Block Updates\nIs this the tip of the chain?\nSerializable Parallel Download Processor\nSimple general purpose utility functions.\nTransaction Witness\nThe maximum number of times we wait for a nodeChainUpdate …\nThe maximum number of seconds we wait for a node to …\nHow long we wait before trying to reconnect to a peer when …\nHandle the background downloading of Mithril snapshots for …\nFetch a single block from the Peer, and Decode it.\nFollows the chain until there is an error. If this returns …\nBackfill the live chain, based on the Mithril Sync updates.\nBackfill and Purge the live chain, based on the Mithril …\nDo not return until we have a connection to the peer.\nIs the current point aligned with what we know as tip.\nProcess a rollback detected from the peer.\nProcess a rollback detected from the peer.\nProcess a rollback.\nPurge the live chain, and intersect with TIP.\nResynchronize to the live tip in memory.\nTry and connect to a node, in a robust and quick way.\nA Follower Connection to the Cardano Network.\nDefault Follower block buffer size.\nHow many slots back from TIP is considered Immutable in …\nHandle to the mithril sync thread. One for each Network …\nType we use to manage the Sync Task handle map.\nChain Network\nSets the size of the chain updates buffer used by the …\nBlock buffer size option.\nSets the defaults for a given cardano network. Each …\nReturns the argument unchanged.\nSets the size of the Immutable window used when Mithril is …\nIf we don’t have immutable data, how far back from TIP …\nCalls <code>U::from(self)</code>.\nSets the the Mithril snapshot Config the <code>ChainSync</code> will …\nConfiguration of Mithril Snapshots.\nSets the relay to use for Chain Sync.\nRelay Node Address\nRuns Chain Synchronization.\nNumber of seconds to wait if we detect a <code>SyncReady</code> race …\nHandle to the mithril sync thread. One for each Network …\nType we use to manage the Sync Task handle map.\nLatest TIP received from the Peer Node.\nBecause we have multi-entry relationships in the …\nAdds a block to the tip of the live chain, and …\nAtomic Backfill the chain with the given blocks Blocks …\nFind best block from a fork relative to a point.\nGiven a known point on the live chain, and a fork count, …\nReturns the argument unchanged.\nGet the <code>nth</code> Live block immediately following the specified …\nGet the earliest block in the Live Chain\nGet the fill tp point for a chain.\nGet the point of the first known block in the Live Chain.\nGet intersection points to try and find best point to …\nGet chain sync intersection points for communicating with …\nGet the point of the first known block in the Live Chain.\nGet the Live block relative to the specified point. The …\nGet the <code>LiveChainBlockList</code> for a particular <code>Network</code>.\nGet the head <code>Point</code> currently in the live chain.\nGet the point of the block at the head of the live chain.\nSet the last TIP received from the peer.\nCalls <code>U::from(self)</code>.\nGet the current number of blocks in the live chain\nInsert a block into the live chain (in-order). Can ONLY be …\nBackfill the live chain with the block set provided.\nGet the length of the live chain. Probably used by debug …\nCreate a new instance of the protected Live Chain skip map.\nChecks if the point exists in the live chain. If it does, …\nOn an immutable update, purge the live-chain up to the new …\nCheck if the given point is strictly in the live-chain.  …\nSet the last TIP received from the peer.\nLock to prevent using any blockchain data for a network …\nNumber of seconds to wait if we detect a <code>SyncReady</code> race …\nData we hold related to sync being ready or not.\nWaiter for sync to become ready, use <code>signal</code> when it is.\nBlock until the chain is synced to TIP. This is necessary …\nGet a Read lock on the Sync State, and return if we are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the Broadcast Receive queue for the given chain …\nGet the Broadcast Transmit queue for the given chain …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>SyncReady</code> state.\nSand a chain update to any subscribers that are listening.\nSync is ready flag. (Prevents data race conditions)\nMPMC Receive queue for Blockchain Updates\nCreate a new <code>SyncReadyWaiter</code> state.\nThe oneshot queue we use to signal ready.\nMPMC Transmit queue for Blockchain Updates\nWrite Lock the <code>SYNC_READY</code> lock for a network. When we are …\nNew block inserted on chain.\nActual Chain Update itself.\nA new part of the chain has become immutable …\nEnum of chain updates received by the follower.\nChain rollback to the given block.\nGets the chain update’s block data.\nWhat is the new data?\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the chain update’s block data.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhat kind of update is this?\nCreates a new chain update.\nIs this the tip of the chain?\nBackfill Synch error.\nBlockfetch protocol error.\nChain Sync already running error.\nChainsync protocol error.\nClient connection error.\nData encoding/decoding error.\nContains the error value\nCrate error type.\nFollower background follow task has stopped.\nInternal Error\nLive Sync error.\nMithril aggregator URL is already defined for a network.\nMithril aggregator URL is already defined for a network.\nMithril aggregator URL is not a valid URL\nGeneral Mithril Client Error\nMithril Aggregator mismatch\nMithril Aggregator has no Snapshots\nMithril genesis VKEY Mismatch\nMithril genesis VKEY is not properly HEX Encoded\nGeneral Mithril Index DB Error\nMithril snapshot error.\nMithril snapshot chunk error.\nMithril Snapshot path is already configured for this …\nMithril Snapshot path is already configured for another …\nMithril snapshot directory failed to be created.\nMithril Snapshot path not configured, trying to start …\nMithril Snapshot path is not a directory\nMithril snapshot directory is not writable and we need to …\nMithril snapshot already running error.\nMithril snapshot traversal error.\nMithril Auto-update requires an Aggregator and a VKEY and …\nContains the success value\nFailed to parse\nCrate result type.\nFollower failed to set its read pointer.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe Chain Follower\nThe Blockchain network we are following.\nWhere we are currently in the following process.\nWhere we end following.\nWhat fork were we last on\nReturns the argument unchanged.\nGet a single block from the chain by its point.\nGet the current Immutable and live tips.\nCalls <code>U::from(self)</code>.\nMithril Snapshot Follower\nMithril TIP Reached\nFollow a blockchain.\nGet the next block from the follower. Returns NONE is …\nIf we can, get the next update from the mithril snapshot.\nIf we can, get the next update from the mithril snapshot.\nSchedule a transaction to be posted to the blockchain.\nBlock we processed most recently.\nMithril Snapshot\nLive Block Updates\nCheck if a transaction, known by its <code>TxId</code>, has been sent …\nThis is an unprotected version of <code>next()</code> which can ONLY be …\nUpdate the current Point, and return <code>false</code> if this fails.\nCIP-36/CIP-15 Catalyst Registration metadata.\nCIP-509 RBAC metadata.\nDecoded Metadata for a single transaction. The key is the …\nAn individual decoded metadata item.\nPossible Decoded Metadata Values. Must match the key they …\nDecoded Metadata for a all transactions in a block. The …\nList of all validation errors (as strings) Metadata is …\nDecoder and Validator for CIP36 Metadata\nCardano Improvement Proposal 509 (CIP-509) metadata module.\nThe Decoded Metadata for each transaction in the block.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the decoded metadata item at the given slot, or None …\nGet metadata for a given label in a transaction if it …\nGet raw metadata for a given label in a transaction if it …\nInsert another transaction worth of data into the Decoded …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new decoded metadata for a transaction.\nCreate a new <code>DecodedTransaction</code>.\nThe Raw Auxiliary Data for each transaction in the block.\nRaw Auxiliary Data Decoding\nValidation report for this metadata item.\nThe decoded metadata itself.\nCIP 36 Registration Data.\nEd25519 Public Key\nCIP36 Metadata Label\nProject Catalyst Purpose\nSigndata Preamble = <code>{ 61284: ?? }</code> CBOR Decoded = A1       …\nCIP36 Metadata Signature label\nVoting Public Key - Also known as Delegation in the CIP36 …\nIs this CIP36 or CIP15 format.\nDecode and validate CIP36/15 Metadata\nDecode an individual delegation entry from the CIP36 …\nDecode the Payment Address Metadata in the CIP36 Metadata …\nDecode number of entries in the CIP36 metadata map.\nDecode the Key of an entry in the CIP36 Metadata map.\nDecode the Registration Nonce in the CIP36 Metadata map.\nDecode the Payment Address Metadata in the CIP36 Metadata …\nDecode the Registration Purpose in the CIP36 Metadata map.\nDecode the Staking Public Key in the CIP36 Metadata map.\nDecode the Voting Key(s) in the CIP36 Metadata map.\nDecoding of the CIP36 metadata failed, and can not …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNonce (Nonce that has been slot corrected)\nIs the address able to be paid to? (Can’t be a script or …\nPayment Address to associate with the Voting Keys No …\nRegistration Purpose (Always 0 for Catalyst)\nRaw Nonce (Nonce that has not had slot correction applied)\nSignature Validates\nStake Address to associate with the Voting Keys\nStrict Catalyst Validated\nDecode a signature from the Signature metadata in 61285 …\nVoting Keys (Called Delegations in the CIP-36 Spec) If No …\nEd25519 Public Key\nWeight of the Voting Public Key\nCIP509 metadatum.\nEnum of CIP509 metadatum with its associated unsigned …\nValidation value for CIP509 metadatum.\nCIP509 label.\nPrevious transaction ID.\nPurpose.\nSubject Alternative Name OID\nTransaction inputs hash.\nContext-specific primitive type with tag number 6 (<code>raw_tag</code> …\nValidation signature.\nDecode and validate CIP509 Metadata\nCbor decoding helper functions for CIP-509 metadata.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to create Self from the raw representation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBytes of precomputed auxiliary data.\nOptional previous transaction ID.\n<code>UUIDv4</code> Purpose .\nRole Based Access Control (RBAC) metadata for CIP509. Doc …\nTransaction inputs hash.\nUtility functions use in CIP-509\nBoolean value for the validity of the auxiliary data.\nBoolean value for the validity of the payment key.\nBoolean value for the validity of the public key.\nBoolean value for the validity of the transaction inputs …\nValidate the auxiliary data with the auxiliary data hash …\nHelper function for auxiliary data validation.\nValidate the payment key\nHelper function for validating payment output key.\nValidate the stake public key in the certificate with …\nTransaction inputs hash validation. Must exist and match …\nValidation value, not a part of CIP509, justs storing …\nHandle validation failure.\nValidation signature.\nX509 chunks handler where compressed chunks are …\nx509 chunks.\nDecode any in CDDL, only support basic datatype\nHelper function for decoding array.\nHelper function for decoding bytes.\nHelper function for decoding i16.\nHelper function for decoding i32.\nHelper function for decoding i64.\nHelper function for decoding i8.\nHelper function for decoding map.\nHelper function for decoding string.\nHelper function for decoding tag.\nHelper function for decoding u16.\nHelper function for decoding u32.\nHelper function for decoding u64.\nHelper function for decoding u8.\nc509 certificates.\nStruct of Cip509 RBAC metadata.\nEnum of CIP509 RBAC metadata with its associated unsigned …\nThe first valid purpose key.\nThe last valid purpose key.\nPublic keys.\nRevocation list.\nRole data set.\nx509 certificates.\nOptional list of c509 certificates. The value can be …\nCertificates for the RBAC metadata.\nDecode an array of type T.\nDecode an array of revocation list.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to create Self from the raw representation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new instance of <code>Cip509RbacMetadata</code>.\nPublic key type for RBAC metadata\nOptional list of Public keys.\nOptional map of purpose key data. Empty map if no purpose …\nOptional list of revocation list.\nRole data for RBAC metadata.\nOptional list of role data.\nSet the c509 certificates.\nSet the public keys.\nSet the revocation list.\nSet the role data set.\nSet the x509 certificates.\nOptional list of x509 certificates.\nEnum of possible c509 certificate.\nA struct of c509 certificate in metadatum reference.\nA c509 certificate in metadatum reference.\nA c509 certificate.\nA struct of X509 certificate.\nOptional certificate reference.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTransaction output field.\nTransaction output index.\nDeleted Key tag 31.\nDeleted indicates the key is deleted.\nEd25519 Key tag 32773.\nEd25519 key.\nEnum of possible public key tag.\nEnum of possible public key type.\nUndefined indicates skipped element.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the tag value.\nc509 certificates.\nThe first valid role extended data key.\nKey hash.\nStruct of key local reference.\nKey local reference.\nEnum of key reference.\nThe last valid role extended data key.\nEnum of local reference with its associated unsigned …\nPayment key.\nPublic keys.\nStruct of role data.\nEnum of role data with its associated unsigned integer …\nRole encryption key.\nRole number.\nRole signing key.\nx509 certificates.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to create Self from the raw representation\nTry to create Self from the raw representation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKey offset.\nLocal reference.\nOptional payment key.\nOptional role encryption key.\nOptional role extended data keys. Empty map if no role …\nRole number.\nOptional role signing key.\nCompare the given public key bytes with the transaction …\nGetting the index by decrementing by 1. e.g. 1 should …\nExtracts the CIP-19 bytes from a URI. Example input: …\nExtract the first 28 bytes from the given key Refer to …\nZero out the last n bytes\nBrotli compression.\nEnum of compression algorithms used to compress chunks.\nRaw data, no compression.\nStruct of x509 chunks.\nZstd compression.\nDecompress the data using the given algorithm.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to create Self from the raw representation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new instance of <code>X509Chunks</code>.\nNative smart contracts\nPlutus smart contracts (with version number 1-x)\nWhat type of smart contract is this list.\nDecode a Shelley-MA Auxiliary Data Array\nDecode an array of smart contract scripts\nDecode a Shelley-MA Auxiliary Data Array\nDecode the Shelley map of metadata.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet Raw metadata for a given metadata label, if it exists.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMetadata: key = label, value = raw metadata bytes\nCreate a new <code>RawDecodedMetadata</code>.\nScripts: 1 = Native, 2 = Plutus V1, 3 = Plutus V2, 4 = …\nSynchronous Immutable block iterator.\nGet latest TIP of the Mithril Immutable Chain.\nGet a mithril snapshot iterator.\nHolds information about a Mithril snapshot.\nNetwork that this snapshot is configured for\nChecks if the snapshot contains a given point.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new Mithril Snapshot handler\nRead a single block from a known point.\nTries get an iterator that reads blocks from the Mithril …\nConfiguration used for the Mithril Snapshot downloader.\nMessage we send when Mithril Snapshot updates\nHandle to the mithril sync thread. One for each Network …\nType we use to manage the Sync Task handle map.\nSubdirectory where we unpack archives temporarily.\nActivate the tmp mithril path to a numbered snapshot path. …\nAddress of the Mithril Aggregator to use to find the …\nWhat Blockchain network are we configured for.\nCheck that a given mithril snapshot path and everything in …\nCleanup the tmp mithril path, all old mithril paths and …\nDeduplicate a file in the tmp directory vs its equivalent …\nSets the defaults for a given cardano network. Each …\nDownloader configuration.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe Genesis Key needed for a network to do Mithril …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a string is an even number of hex digits.\nReturns the path to the Numbered Snapshot Data. Will use a …\nPath to the Mithril snapshot the follower should use. …\nThe block immediately before it.\nTry and recover the latest snapshot id from the files on …\nRemove whitespace from a string and return the new string\nRun a Mithril Follower for the given network and …\nThe largest block on the mithril snapshot.\nReturns the path to Latest Tmp Snapshot Data. Will use a …\nValidate the mithril sync configuration is correct.\nValidate the Aggregator is resolvable and responsive.\nValidate the Genesis VKEY is at least the correct kind of …\nCheck if the Mithril Snapshot Path is valid an usable.\nSet a custom downloader configuration.\nCurrent Mithril Snapshot for a network.\nCurrent Mithril Snapshot Data for a network.\nThe default snapshot data represents there is no latest …\nReturns the argument unchanged.\nGet the snapshot ID of this Snapshot Data.\nSnapshot ID the data represents\nCalls <code>U::from(self)</code>.\nGet the current latest snapshot data we have recorded.\nGet the latest Mithril Snapshot for a network.\nCreate a new Snapshot Data.\nUpdate the latest snapshot data.\nSearch backwards by 60 slots (seconds) looking for a …\nWraps the iterator type returned by Pallas.\nSynchronous Inner Iterator state\nThe chain being iterated\nReturns the argument unchanged.\nReturns the argument unchanged.\nDo a fuzzy search to establish the iterator. We use this …\nInner iterator.\nInner Mutable Synchronous Iterator State\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a mithril iterator, optionally where we know the …\nGet the next block, in a way that is Async friendly. …\nPrevious iteration point.\nCreate a probe point used in iterations to find the start …\nWhere we really want to start iterating from\nTry and probe to establish the iterator from the desired …\nWe shouldn’t get errors that need to wait for this, but …\nAverage Mithril Update is 6 Hrs, so don’t wait longer …\nAverage Mithril Update is 6 Hrs, so don’t wait longer …\nThe minimum duration between checks for a new Mithril …\nThe minimum duration between checks for a new Mithril …\nRelative Directory for Immutable data within a full …\nNo update, sleep for this long before checking again\nStatus of checking if we have a new snapshot to get or not.\nSnapshot has updated, here are the details.\nHandle the background downloading of Mithril snapshots for …\nStart Mithril Validation in the background, and return a …\nCalculate how long we should wait before we check for …\nCheck if we have a new snapshot to download, and if so, …\nConvert a chunk filename into its numeric equivalent.\nWe can accumulate junk depending on errors or when we …\nThis function creates a client based on the given network …\nCreate a client, should never fail, but return None if it …\nDownloads and validates a snapshot from the aggregator.\nDownload and Verify the Snapshots certificate\nReturns the argument unchanged.\nReturns the Latest and chronologically previous snapshots …\nSee if we have a latest snapshot already, and if so, …\nGet the Snapshot Data itself from the Aggregator, and a …\nGet the tip block from the Immutable chain, and the block …\nGet the actual snapshot from the specified <code>snapshot_item</code> …\nGiven a particular snapshot ID, find the Actual Snapshot …\nCalls <code>U::from(self)</code>.\nCleanup the client explicitly and do a new iteration of …\nGet the Mithril client and recover our existing mithril …\nSleep until its likely there has been another mithril …\nRemove any chunks from the chunk list which exceed the …\nValidate that a Mithril Snapshot downloaded matches its …\nA snapshot downloader that accelerates Download using <code>aria2</code>…\nA snapshot downloader that accelerates Download using <code>aria2</code>…\nCheck if a given path from the archive is able to be …\nConfiguration for the snapshot sync.\nThis macro is what happens every time the file is …\nCheck if we are supposed to extract this file from the …\nThe number of files that changed in this download.\nCreate a TAR archive extractor from the downloading file …\nCreate directories required to exist for download to …\nThe total size of the files we deduplicated.\nSynchronous Download and Dedup archive.\nParallel Download, Extract and Dedup the Mithril Archive.\nThe download processor for the current file download.\nThe total size of the files extracted in the download.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the size of a particular file.  None = failed to get …\nTake the hashmap for the previous download.\ninner arc wrapped configuration\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOpen a file using mmap for performance.\nConstructs a new <code>HttpSnapshotDownloader</code>.\nLast hashmap/list of changed chunks from the previous …\nThis macro is what happens every time we decide the file …\nThe number of files that were new in this download.\nThe total number of files in the download.\nMulti-era block.\nMulti-era block - inner.\nWhat chain was the block from\nWhat blockchain was the block produced on.\nCompare two <code>LiveBlocks</code> by their points. Only checks the …\nThe decoded multi-era block.\nDecodes the data into a multi-era block.\nCompare two <code>MultiEraBlock</code> by their current points. Ignores …\nWhat fork is the block from.\nWhat fork is the block on? This is NOT part of the inner …\nReturns the argument unchanged.\nReturns the argument unchanged.\nIs the block data immutable on-chain.\nThe Immutable decoded data about the block itself.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDecoded Metadata in the transactions in the block.\nCreates a new <code>MultiEraBlockData</code> from the given bytes.\nCreates a new <code>MultiEraBlockData</code> from the given bytes.\nEncapsulates implementation details for a self-referencing …\nCompare two <code>MultiEraBlock</code> by their points. Only checks the …\nCompare a <code>MultiEraBlock</code> to a <code>Point</code> by their points. Only …\nReturns the block point of this block.\nThe Point on the blockchain this block can be found.\nReturns the block point of the previous block.\nThe previous point on the blockchain before this block. …\nDecodes the data into a multi-era block.\nRemake the block on a new fork.\nGet The Decoded Metadata fora a transaction and known …\nGet The Raw Metadata fora a transaction and known label …\nIf the Witness exists for a given transaction then return …\nReturns the witness map for the block.\nA map of public key hashes to the public key and …\nA struct for holding immutable references to all tail and …\nA struct for holding mutable references to all tail fields …\nA struct which contains only the head fields of …\nThe self-referencing struct.\nA more verbose but stable way to construct …\nA more verbose but stable way to construct …\nA more verbose but stable way to construct …\nA more verbose but stable way to construct …\nA more verbose but stable way to construct …\nA more verbose but stable way to construct …\nProvides an immutable reference to <code>block</code>. This method was …\nProvides limited immutable access to <code>raw_data</code>. This method …\nCalls <code>SelfReferencedMultiEraBlock::new()</code> using the …\nCalls <code>SelfReferencedMultiEraBlock::new()</code> using the …\nCalls <code>SelfReferencedMultiEraBlock::new()</code> using the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis function drops all internally referencing fields and …\nConstructs a new instance of this self-referential struct. …\nConstructs a new instance of this self-referential struct. …\nConstructs a new instance of this self-referential struct. …\nCalls <code>SelfReferencedMultiEraBlock::try_new()</code> using the …\nCalls <code>SelfReferencedMultiEraBlock::try_new()</code> using the …\nCalls <code>SelfReferencedMultiEraBlock::try_new()</code> using the …\nCalls <code>SelfReferencedMultiEraBlock::try_new_or_recover()</code> …\nCalls <code>SelfReferencedMultiEraBlock::try_new_or_recover()</code> …\nCalls <code>SelfReferencedMultiEraBlock::try_new_or_recover()</code> …\n(See also …\n(See also …\n(See also …\n(See also …\n(See also …\n(See also …\nThis method provides immutable references to all tail and …\nProvides an immutable reference to <code>block</code>. This method was …\nProvides a mutable reference to <code>block</code>. This method was …\nThis method provides mutable references to all tail fields.\nProvides limited immutable access to <code>raw_data</code>. This method …\nDefault name of the executable if we can’t derive it.\nDefault Mithril Aggregator to use.\nMain-net Mithril Signature genesis vkey.\nMainnet Default Public Cardano Relay.\nDefault Mithril Aggregator to use.\nPreprod network Mithril Signature genesis vkey.\nPreprod Default Public Cardano Relay.\nDefault Mithril Aggregator to use.\nPreview network Mithril Signature genesis vkey.\nPreview Default Public Cardano Relay.\nENV VAR name for the data path.\nENV VAR name for the executable name.\nCardano mainnet network.\nEnum of possible Cardano networks.\nAn iterator over the variants of Network\nCardano pre-production network.\nCardano preview network.\nGet the default aggregator for a blockchain.\nGet the default Mithril Signature genesis key for a …\nGet the default storage location for mithril snapshots. …\nGet the default Relay for a blockchain network.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn genesis values for given network\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert a given slot# to its Wall Time for a Blockchain …\nConvert an arbitrary time to a slot.\nThe origin of the blockchain. It is used when the interest …\nA specific point in the blockchain. It can be used to …\nThe tip of the blockchain at the current moment. It is …\nA truly unknown point in the blockchain. It is used when …\nCreates a new Fuzzy <code>Point</code> from a concrete point.\nImplements a total ordering based on the slot number of …\nCompares the hash stored in the <code>Point</code> with a known hash. …\nCompare Points, because Pallas does not impl <code>Ord</code> for Point.\nReturns the default value for <code>Point</code>, which is <code>UNKNOWN_POINT</code>…\nAllows to compare a <code>SnapshotID</code> against <code>u64</code> (Just the …\nAllows to compare a <code>SnapshotID</code> against <code>u64</code> (Just the …\nReturns the argument unchanged.\nCreates a new <code>Point</code> instance representing a specific point …\nRetrieves the hash from the <code>Point</code>. If the <code>Point</code> is the …\nCalls <code>U::from(self)</code>.\nCheck if a Point is Fuzzy.\nCheck if a Point is the origin.\nCheck if a Point is actually unknown.\nCheck if a Point is actually unknown.\nCreates a new <code>Point</code> instance representing a specific point …\nAllows to compare a <code>Point</code> against a <code>u64</code> (Just the …\nAllows to compare a <code>Point</code> against a <code>u64</code> (Just the …\nImplements a partial ordering based on the slot number of …\nRetrieves the slot number from the <code>Point</code>. If the <code>Point</code> is …\nChecks if two <code>Point</code> instances are strictly equal. Strict …\nA Representation of a Snapshot Path and its represented …\nCreate an empty <code>SnapshotID</code>.\nThe largest Immutable File Number\nConvert this <code>SnapshotID</code> to a <code>String</code>.\nReturns the argument unchanged.\nGet the Immutable Blockchain path from this <code>SnapshotId</code>\nCalls <code>U::from(self)</code>.\nTry and create a new <code>SnapshotID</code> from a given path. …\nSee if we can Parse the path into an immutable file number.\nGet the Blockchain path from this <code>SnapshotId</code>\nThe Snapshot Path\nGet the Blockchain path from this <code>SnapshotId</code> only if it …\nGet the Tip of the Immutable Blockchain from this …\nThe Tip of the Snapshot\nTry and create a new <code>SnapshotID</code> from a given path. …\nDownload Or Validation Failed\nValidation Failed\nFailed to activate new snapshot\nFailed to get tip from mithril snapshot.\nValidation Finished\nIndividual Follower stats\nRollback synthesized for the Follower.\nStatistics related to the live blockchain\nRollback on the in-memory live chain.\nStatistics related to Mithril Snapshots\nMithril Sync Failures.\nState of the Mithril cert validation.\nRollback signaled by the peer.\nStatistics of rollbacks detected per chain.\nStatistics related to a single depth of rollback\nRecord of rollbacks.\nIndividual rollback records.\nThe types of rollbacks we track for a chain.\nAn iterator over the variants of RollbackType\nRollback Records per rollback type.\nStatistics for all our known rollback types Rollback Vec …\nThe statistics being maintained per chain.\nValidation Started\nStatistics for a single follower network.\nType we use to manage the Sync Task handle map.\nTip failed to advance\nFailed to send new tip to updater.\nReturn the statistics formatted as JSON\nWhen backfill ended\nWhen did we start the backfill.\nThe time of the last backfill failure\nBackfill Failures\nBackfill size to achieve synchronization. (0 before sync …\nWhen backfill started\nWhen did we start the backfill.\nCurrent Number of Live Blocks\nNumber of changed files from previous snapshot.\nIs there an active connection to the node\nHow many times has a rollback been this deep.\nCurrent slot for this follower.\nNumber of identical files deduplicated from previous …\nDeduplicated Size vs previous snapshot.\nHow deep was the rollback from tip.\nTime we finished downloading the current snapshot. if &lt; …\nNumber of times download failed (bad server connection)\nThe size of the download archive, in bytes. (If not …\nTime we started downloading the current snapshot. …\nDownload Or Validation Failed\nTarget slot for this follower (MAX U64 == Follow Tip …\nExtraction end time. if <code>extract_end</code> &lt; <code>extract_start</code> its …\nNumber of times extraction failed (bad archive)\nSize of last extracted snapshot, in bytes.\nExtraction start time. 1/1/1970-00:00:00 UTC = Never …\nFailed to activate new snapshot\nFailed to get tip from mithril snapshot.\nThese are the rollbacks synthesized for followers, based …\nActive Followers (range and current depth)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe current head of the live chain slot#\nSynthetic follower connection ID\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBlocks that failed to deserialize from the mithril …\nBlocks that failed to deserialize from the blockchain.\nLast reconnect time,\nLast reconnect time,\nLast disconnect time,\nLast disconnect time,\nThe time the last download took, in seconds.\nThese are the ACTUAL rollbacks we did on our live-chain in …\nStatistics related to the live connection to the …\nGet the actual rollback map for a chain.\nGet the stats for a particular chain.\nStatistics related to the mithril certified blockchain …\nRecord when DL finished, if it fails, set size to None, …\nRecord that a Mithril snapshot Download has started.\nRecord when DL finished, if it fails, set size to None, …\nRecord that extracting the mithril snapshot archive has …\nRecord when Mithril Cert validation starts, ends or fails).\nRecord when Mithril Cert validation starts, ends or fails).\nGet a new statistics struct for a given blockchain network.\nNumber of new files from previous snapshot.\nNew blocks read from blockchain.\nCount the validly deserialized blocks\nTrack the end of the current mithril update\nThese are the rollbacks reported by the Peer Node, which …\nTrack statistics about connections to the cardano peer …\nNumber of times we connected/re-connected to the Node.\nReset incremental counters in the mithril statistics.\nReset incremental counters in the live statistics.\nReset amd return cumulative counters contained in the …\nReset the incremental counters in a stats record.\nCount a rollback\nExtract the current rollback stats as a vec.\nRollback statistics.\nReset ALL the rollback stats for a given blockchain.\nStarting slot for this follower (0 = Start at Genesis …\nCount the invalidly deserialized blocks\nWhen this follower reached TIP or its destination slot.\nThe Time that synchronization to this blockchain was …\nCurrent Sync Time.\nThe Time that synchronization to this blockchain started\nRecord when we started syncing\nThe Immutable TIP Slot# - Origin = No downloaded snapshot\nThe current live tip slot# as reported by the peer.\nTip failed to advance\nFailed to send new tip to updater.\nRecord when we first reached tip. This can safely be …\nGet the current tips of the immutable chain and live chain.\nNumber of Mithril Snapshots that have downloaded …\nMithril Certificate Validation End Time. if validate end &lt; …\nNumber of times validation failed (bad snapshot)\nMithril Certificate Validation Start Time. …\nA Simple DNS Balancing Resolver\nAn Individual Downloaded block of data. Wrapped in an ARC …\nDownloaded Chunk (or error if it fails).\nParallel Downloader Tuning parameters\nDownload Chunk Work Order. This is simply the number of …\nMinimum rational size of a chunk in bytes.\nParallel Download Processor.\nParallel Download Processor Inner struct.\nWe only have one resolver.\nStatistic tracking number of bytes downloaded per worker.\nA Cache of the Sockets we already resolved for a URL.\nConfiguration\nThe data from the chunk. (None == failed)\nGet inclusive end offset of a chunk.\nIndex of the chunk in the file.\nSize of a chunk in bytes (except the last).\nGet start offset of a chunk.\nCleanup workers and queues when done.\nTimeout for each connection.\nTimeout for each data read.\nGet current size of data we downloaded.\nStarts Downloading the file using parallel connections.\nCleanup the channel and workers.\nSize of the file we expect to download.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSend a HEAD request to obtain the length of the file we …\nSend a HEAD request to obtain the length of the file we …\nSends a GET request to download a chunk of the file at the …\nInitialize the resolver, only does something once, but …\nActual Read function, done like this so we can have a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe last chunk we can request\nLeft Over Bytes (from the reader)\nBuilds a <code>UReq</code> Agent.\nCreate a new <code>DlConfig</code>\nCreates a new instance of the Parallel Download Processor.\nNew Chunk Queue - Just says we added a new chunk to the …\nNew Chunk Queue - Just says we added a new chunk to the …\nNext Expected Chunk\nNext Chunk to Request\nMaximum number of chunks queued ahead to workers.\nQueue Chunk to processor.\nSkip map used to reorder incoming chunks back into …\nResolve the given URL with the configured resolver.\nResolve DNS addresses using Hickory Resolver\nThe actual resolver\nSend a work order to a worker.\nStarts the worker tasks, they will not start doing any …\nGet how many bytes were downloaded, total.\nURL to download from.\nChange the chunk size\nChange the connection timeout\nChange the data read timeout\nChange the number of chunks queued ahead to workers\nChange the number of workers\nA queue for each worker to send them new work orders.\nThe worker task - It is running in parallel and downloads …\nIndex of the worker that fetched the chunk.\nMaximum number of parallel connections to use.\nConvert the given value to <code>blake2b_128</code> array.\nConvert the given value to <code>blake2b_244</code> array.\nConvert the given value to <code>blake2b_256</code> array.\nDecode the given UTF-8 content.\nConvert T to an i16. (saturate if out of range.)\nConvert an <code>&lt;T&gt;</code> to <code>u32</code>. (saturate if out of range.)\nConvert an <code>&lt;T&gt;</code> to <code>u64</code>. (saturate if out of range.)\nConvert an <code>&lt;T&gt;</code> to <code>usize</code>. (saturate if out of range.)\n<code>TxWitness</code> struct to store the witness data.\n<code>WitnessMap</code> type of <code>DashMap</code> with key as [u8; 28] = (…\nCheck whether the public key hash is in the given …\nReturns the argument unchanged.\nGet the actual address from the given public key hash.\nCalls <code>U::from(self)</code>.\nCreate a new <code>TxWitness</code> from a list of <code>MultiEraTx</code>.")